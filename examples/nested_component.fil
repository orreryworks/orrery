diagram component;

// Define component types
type Database = Rectangle [fill_color = "#B3E5FC", stroke=[color="#0288D1"], rounded = 5.0];
type Service = Rectangle [fill_color = "#FFECB3", stroke=[color="#FFA000"], rounded = 10.0];
type Frontend = Oval [fill_color = "#E8F5E9", stroke=[color="#388E3C"]];
type Cache = Rectangle [fill_color = "#DCEDC8", stroke=[color="#7CB342"], rounded = 8.0];

// Define the outer components
web_app: Frontend;
api: Service;

// Define a database server with inner components
db_server: Rectangle {
    primary_db: Database;
    replica_db: Database;
    cache: Cache;

    // Relations between inner components
    primary_db -> replica_db;
    primary_db -> cache;
};

// External components
logging_service: Service;
metrics: Service;

// Define regular relations between top-level components
web_app -> api;
api -> db_server;
web_app -> logging_service;

// Cross-level relations connecting across different nesting levels
// Access from top-level component directly to nested component
api -> [color = "#E91E63"] db_server::primary_db;

// Direct connection from web app to the replica database
web_app -> [color = "#9C27B0"] db_server::replica_db;

// Connection from nested component to top-level component
db_server::cache -> [color = "#009688"] logging_service;

// External logging service connected to internal component
metrics -> [color = "#FF9800"] db_server::primary_db;

// Commentary on cross-level relations:
// - These relations demonstrate how components at different nesting levels
//   can be connected directly using the hierarchical ID syntax (parent::child)
// - This enables explicit modeling of dependencies that cross boundaries
//   while still maintaining the organizational structure
